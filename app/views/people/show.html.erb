<%- content_for(:head) do -%>
<%= javascript_include_tag "jit" -%>
<%= stylesheet_link_tag "jit-spacetree" -%>
<%- end -%>

<%- content_for(:body_tag_attributes) do -%>
onLoad="init();"
<%- end -%>

<script type="text/javascript">

function init()
{
  var people = <%= strip_tags( @person.ancestry_json ) %>;

  //Create a new ST instance  
  var st = new $jit.ST({  
    //make it a multitree
    multitree: true,
    //set orientation of the tree
    orientation: 'top',
    //id of viz container element  
    injectInto: 'infovis',  
    //set distance between node and its children  
    levelDistance: 50,  
    //enable panning  
    Navigation: {  
      enable:true,  
      panning:true
    },  
    //set node and edge styles  
    //set overridable=true for styling individual  
    //nodes or edges  
    Node: {  
      height: 20,  
      width: 60,  
      type: 'rectangle',  
      color: '#aaa',  
      autoHeight: true,
      overridable: true  
    },  
      
    Edge: {  
      type: 'bezier',  
      overridable: true  
    },  
      
    //This method is called on DOM label creation.  
    //Use this method to add event handlers and styles to  
    //your node.  
    onCreateLabel: function(label, node) {
      label.id = node.id;              
      label.innerHTML = node.name;  
      label.onclick = function() {
        document.location.href = '/people/'+node.id;
      };  
      //set label styles  
      var style = label.style;  
      style.width = 60 + 'px';  
      style.height = 17 + 'px';              
      style.cursor = 'pointer';  
      style.color = '#333';  
      style.fontSize = '0.8em';  
      style.textAlign= 'center';  
      style.padding = '3px';  
    },  
      
    //This method is called right before plotting  
    //a node. It's useful for changing an individual node  
    //style properties before plotting it.  
    //The data properties prefixed with a dollar  
    //sign will override the global node style properties.  
    onBeforePlotNode: function(node) {
      //add some color to the nodes in the path between the  
      //root node and the selected node.  
      if (node.selected) {  
        node.data.$color = "#ff7";  
      }  
      else {  
        delete node.data.$color;  
        //if the node belongs to the last plotted level  
        if(!node.anySubnode("exist")) {  
          //count children number  
          var count = 0;  
          node.eachSubnode(function(n) { count++; });  
          //assign a node color based on  
          //how many children it has  
          node.data.$color = ['#aaa', '#baa', '#caa', '#daa', '#eaa', '#faa'][count];                      
        }  
      }  
    },  
      
    //This method is called right before plotting  
    //an edge. It's useful for changing an individual edge  
    //style properties before plotting it.  
    //Edge data proprties prefixed with a dollar sign will  
    //override the Edge global style properties.  
    onBeforePlotLine: function(adj) {
      if (adj.nodeFrom.selected && adj.nodeTo.selected) {  
        adj.data.$color = "#eed";  
        adj.data.$lineWidth = 3;  
      }  
      else {  
        delete adj.data.$color;  
        delete adj.data.$lineWidth;  
      }  
    }  
  });  
  //load json data  
  st.loadJSON(people);  
  //compute node positions and layout  
  st.compute();  
  st.select(st.root);
}

$(function() {
  $( "#infovis" ).resizable();
});

$(document).ready(function(){

  $('#create_partnership_form')
    .bind("ajax:beforeSend", function(evt, xhr, settings){
      var $submitButton = $(this).find('input[name="commit"]');

      // Update the text of the submit button to let the user know stuff is happening.
      // But first, store the original text of the submit button, so it can be restored when the request is finished.
      $submitButton.data( 'origText', $(this).text() );
      $submitButton.text( "Saving..." );

    })
    .bind("ajax:success", function(evt, data, status, xhr){
      var $form = $(this);

      // Reset fields and any validation errors, so form can be used again, but leave hidden_field values intact.
      $form.find('textarea,input[type="text"],input[type="file"]').val("");
      $form.find('div.validation-error').empty();

      // Insert response partial into page below the form.
      $('#partnerships').append(xhr.responseText);

    })
    .bind('ajax:complete', function(evt, xhr, status){
      var $submitButton = $(this).find('input[name="commit"]');

      // Restore the original submit button text
      $submitButton.text( $(this).data('origText') );
    })
    .bind("ajax:error", function(evt, xhr, status, error){
      var $form = $(this),
          errors,
          errorText;

      try {
        // Populate errorText with the partnership errors
        errors = $.parseJSON(xhr.responseText);
      } catch(err) {
        // If the responseText is not valid JSON (like if a 500 exception was thrown), populate errors with a generic error message.
        errors = {message: "Please reload the page and try again"};
      }

      // Build an unordered list from the list of errors
      errorText = "There were errors with the submission: \n<ul>";

      for ( error in errors ) {
        errorText += "<li>" + error + ': ' + errors[error] + "</li> ";
      }

      errorText += "</ul>";

      // Insert error list into form
      $form.find('div.validation-error').html(errorText);
    });

});

/* Activate in-place ajaxy editing with best_in_place */
$(document).ready(function() {
    jQuery(".best_in_place").best_in_place()
});
</script>

<div id="infovis" class="ui-widget-content">
  <h3 class="ui-widget-header">Family Tree</h3>
</div>    

<div id="content">
  <p id="notice"><%= notice %></p>

  <table data-nil="<span class='nil'>Click to edit</span>">
    <tr>
      <th>Name:</th>
      <td><%= best_in_place @person, :name, :type => :input %></td>
    </tr>

    <tr>
      <th>Gender:</th>
      <td><%= best_in_place @person, :gender, :type => :select, :collection => [ ['male', 'male'], ['female', 'female'] ] %></td>
    </tr>

    <tr>
      <th>Father:</th>
      <td><%= link_to(@person.father.name, @person.father) if @person.father %></td>
    </tr>

    <tr>
      <th>Mother:</th>
      <td><%= link_to(@person.mother.name, @person.mother) if @person.mother %></td>
    </tr>

    <tr>
      <th>Partners:</th>
      <td><%= render :partial => 'partnerships', :locals => { :person => @person } %>
        <%= 
          form_for :partnership, :remote => true, :url => partnerships_path,
            :html => { 'data-type' => 'html', :id => 'create_partnership_form' } do |f| 
          %>
          Add new partner: 
          <%= f.autocomplete_field :name, autocomplete_person_name_people_path, :id_element => "#partnership_partner_id" %>
          <%= f.hidden_field(:person_id, :value => @person.id) %>
          <%= f.hidden_field(:partner_id) %>
          <%= f.submit %>
          <div class="validation-error"></div>
        <% end %>
      </td>
    </tr>

    <tr>
      <th>Children:</th>
      <td>
        <% 
          if @person.children 
            @person.children.each { |child| 
          %>
          <%= link_to(child.name, child) %>
          <%
              } 
          end 
        %>
      </td>
    </tr>

    <tr>
      <th>Bio:</th>
      <td><%= best_in_place @person, :bio, :type => :textarea, :nil => '<span class="nil">Click to add a biography</span>' %></td>
    </tr>
  </table>


  <%= link_to 'Edit', edit_person_path(@person) %> |
  <%= link_to 'Back', people_path %>
</div>
